#ifndef _SHA512_H_
#define _SHA512_H_

/* Reference: [RFC 6234](https://datatracker.ietf.org/doc/html/rfc6234) */

// TODO: Refactor/Clean the code...

// Macros Functions
#if __has_builtin(__builtin_stdc_rotate_right)
	#define ROTR __builtin_stdc_rotate_right
#elif __has_builtin(__builtin_rotateright64) 
	#define ROTR __builtin_rotateright64
#else
	#define ROTR(x, r) (((x) >> (r)) | ((x) << (64 - (r))))
#endif

#define CH(x, y, z)  (((x) & (y)) ^ ((~(x)) & (z)))
#define MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define BSIG0(x)     (ROTR((x), 28) ^ ROTR((x), 34) ^ ROTR((x), 39))
#define BSIG1(x)     (ROTR((x), 14) ^ ROTR((x), 18) ^ ROTR((x), 41))
#define SSIG0(x)     (ROTR((x), 1)  ^ ROTR((x), 8)  ^ ((x) >> 7))
#define SSIG1(x)     (ROTR((x), 19) ^ ROTR((x), 61) ^ ((x) >> 6))

// -----------------------
//  Function Declarations
// -----------------------
void sha512_init(sha_ctx* ctx);
int sha512_update(sha_ctx* ctx, const u8* data, const u64 len);
int sha512_final(sha_t* digest, sha_ctx* ctx);
int sha512_final_le(sha_t* digest, sha_ctx* ctx);
void sha512_le(const u8* data, const u64 len, sha_t* digest);
void sha512(const u8* data, const u64 len, sha_t* digest);

// ------------------
//  Static Variables
// ------------------
static const sha_fn sha512_fn = {
	.digest_size = SHA512_DIGEST_SIZE,
	.block_size = SHA512_BLOCK_SIZE_IN_BYTES,
	.sha_init = sha512_init,
	.sha_update = sha512_update,
	.sha_final = sha512_final,
	.sha_final_le = sha512_final_le,
	.sha_le = sha512_le,
	.sha = sha512
};

static const u64 costants[] = {
	0x428A2F98D728AE22, 0x7137449123EF65CD, 0xB5C0FBCFEC4D3B2F, 0xE9B5DBA58189DBBC,
	0x3956C25BF348B538, 0x59F111F1B605D019, 0x923F82A4AF194F9B, 0xAB1C5ED5DA6D8118,
	0xD807AA98A3030242, 0x12835B0145706FBE, 0x243185BE4EE4B28C, 0x550C7DC3D5FFB4E2,
	0x72BE5D74F27B896F, 0x80DEB1FE3B1696B1, 0x9BDC06A725C71235, 0xC19BF174CF692694,
	0xE49B69C19EF14AD2, 0xEFBE4786384F25E3, 0x0FC19DC68B8CD5B5, 0x240CA1CC77AC9C65,
	0x2DE92C6F592B0275, 0x4A7484AA6EA6E483, 0x5CB0A9DCBD41FBD4, 0x76F988DA831153B5,
	0x983E5152EE66DFAB, 0xA831C66D2DB43210, 0xB00327C898FB213F, 0xBF597FC7BEEF0EE4,
	0xC6E00BF33DA88FC2, 0xD5A79147930AA725, 0x06CA6351E003826F, 0x142929670A0E6E70,
	0x27B70A8546D22FFC, 0x2E1B21385C26C926, 0x4D2C6DFC5AC42AED, 0x53380D139D95B3DF,
	0x650A73548BAF63DE, 0x766A0ABB3C77B2A8, 0x81C2C92E47EDAEE6, 0x92722C851482353B,
	0xA2BFE8A14CF10364, 0xA81A664BBC423001, 0xC24B8B70D0F89791, 0xC76C51A30654BE30,
	0xD192E819D6EF5218, 0xD69906245565A910, 0xF40E35855771202A, 0x106AA07032BBD1B8,
	0x19A4C116B8D2D0C8, 0x1E376C085141AB53, 0x2748774CDF8EEB99, 0x34B0BCB5E19B48A8,
	0x391C0CB3C5C95A63, 0x4ED8AA4AE3418ACB, 0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3,
	0x748F82EE5DEFB2FC, 0x78A5636F43172F60, 0x84C87814A1F0AB72, 0x8CC702081A6439EC,
	0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9, 0xBEF9A3F7B2C67915, 0xC67178F2E372532B,
	0xCA273ECEEA26619C, 0xD186B8C721C0C207, 0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178,
	0x06F067AA72176FBA, 0x0A637DC5A2C898A6, 0x113F9804BEF90DAE, 0x1B710B35131C471B,
	0x28DB77F523047D84, 0x32CAAB7B40C72493, 0x3C9EBE0A15C9BEBC, 0x431D67C49C100D4C,
	0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A, 0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817
};

void sha512_init(sha_ctx* ctx) {
	mem_set(ctx -> hash.sha512_t, 0, sizeof(sha_t));

	(ctx -> hash.sha512_64_t)[0] = 0x6A09E667F3BCC908;
    (ctx -> hash.sha512_64_t)[1] = 0xBB67AE8584CAA73B;
    (ctx -> hash.sha512_64_t)[2] = 0x3C6EF372FE94F82B;
    (ctx -> hash.sha512_64_t)[3] = 0xA54FF53A5F1D36F1;
    (ctx -> hash.sha512_64_t)[4] = 0x510E527FADE682D1;
    (ctx -> hash.sha512_64_t)[5] = 0x9B05688C2B3E6C1F;
    (ctx -> hash.sha512_64_t)[6] = 0x1F83D9ABFB41BD6B;
    (ctx -> hash.sha512_64_t)[7] = 0x5BE0CD19137E2179;
	
	mem_set(ctx -> msg_block, 0, SHA512_BLOCK_SIZE_IN_BYTES * 2);
	ctx -> msg_block_size = 0;
	ctx -> total_msg_size = 0;
	ctx -> is_finished = FALSE;
	
	return;
}

static void process_block(sha_ctx* ctx) {
	u64 W[80] = {0};

	mem_cpy(W, ctx -> msg_block, SHA512_BLOCK_SIZE_IN_BYTES);
	for (unsigned int t = 0; t < 16; ++t) KOCKET_BE_CONVERT(W + t, 8);
	for (unsigned int t = 16; t < 80; ++t) {
		W[t] = SSIG1(W[t - 2]) + W[t - 7] + SSIG0(W[t - 15]) + W[t - 16];
	}

	u64 a = (ctx -> hash.sha512_64_t)[0];
	u64 b = (ctx -> hash.sha512_64_t)[1];
	u64 c = (ctx -> hash.sha512_64_t)[2];
	u64 d = (ctx -> hash.sha512_64_t)[3];
	u64 e = (ctx -> hash.sha512_64_t)[4];
	u64 f = (ctx -> hash.sha512_64_t)[5];
	u64 g = (ctx -> hash.sha512_64_t)[6];
	u64 h = (ctx -> hash.sha512_64_t)[7];

	for (unsigned int t = 0; t < 80; ++t) {   
		const u64 T1 = h + BSIG1(e) + CH(e, f, g) + costants[t] + W[t];
		const u64 T2 = BSIG0(a) + MAJ(a, b, c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
		d = c;
		c = b;
		b = a;
		a = T1 + T2;
	}

	(ctx -> hash.sha512_64_t)[0] += a;
	(ctx -> hash.sha512_64_t)[1] += b;
	(ctx -> hash.sha512_64_t)[2] += c;
	(ctx -> hash.sha512_64_t)[3] += d;
	(ctx -> hash.sha512_64_t)[4] += e;
	(ctx -> hash.sha512_64_t)[5] += f;
	(ctx -> hash.sha512_64_t)[6] += g;
	(ctx -> hash.sha512_64_t)[7] += h;

	mem_cpy(ctx -> msg_block, ctx -> msg_block + SHA512_BLOCK_SIZE_IN_BYTES, SHA512_BLOCK_SIZE_IN_BYTES);
	mem_set(ctx -> msg_block + SHA512_BLOCK_SIZE_IN_BYTES, 0, SHA512_BLOCK_SIZE_IN_BYTES);
	ctx -> msg_block_size -= SHA512_BLOCK_SIZE_IN_BYTES;

	return;
}

static void pad_block(sha_ctx* ctx) {
	u64 last_block_len = ctx -> msg_block_size;
	u64 k = (896 - ((ctx -> msg_block_size * 8 + 1) % SHA512_BLOCK_SIZE)) % SHA512_BLOCK_SIZE;
	unsigned int blocks_cnt = (last_block_len * 8 + 1 + k + 128) / SHA512_BLOCK_SIZE;
	ctx -> msg_block_size = blocks_cnt * SHA512_BLOCK_SIZE_IN_BYTES;
	
	(ctx -> msg_block)[last_block_len] = 0x80;
	
	((u64*) (ctx -> msg_block))[ctx -> msg_block_size / 8 - 1] = ctx -> total_msg_size * 8;	
	KOCKET_BE_CONVERT(((u64*) (ctx -> msg_block)) + (ctx -> msg_block_size / 8 - 1), 8);

	return;
}

int sha512_update(sha_ctx* ctx, const u8* data, const u64 len) {
	if (ctx -> is_finished) return -KOCKET_UPDATING_FINISHED_CTX;

	u64 copied_size = MIN(len, SHA512_BLOCK_SIZE_IN_BYTES - ctx -> msg_block_size);
	mem_cpy(ctx -> msg_block + ctx -> msg_block_size, data, copied_size);
	ctx -> msg_block_size += copied_size;

	u64 offset = copied_size;
	while (ctx -> msg_block_size >= SHA512_BLOCK_SIZE_IN_BYTES) {
		process_block(ctx);	
		
		if (offset < len) {
			copied_size = MIN(len - offset, SHA512_BLOCK_SIZE_IN_BYTES - ctx -> msg_block_size);
			mem_cpy(ctx -> msg_block + ctx -> msg_block_size, data + offset, copied_size);
			ctx -> msg_block_size += copied_size;
			offset += copied_size;
		}
	}

	ctx -> total_msg_size += len;

	return KOCKET_NO_ERROR;
}

static int __sha512_final(sha_t* digest, sha_ctx* ctx, const bool use_le) {
	if (ctx -> is_finished) return -KOCKET_UPDATING_FINISHED_CTX;
	
	pad_block(ctx);
	
	do {
		process_block(ctx);
	} while (ctx -> msg_block_size);
	
	(digest -> sha512_64_t)[0] = (ctx -> hash.sha512_64_t)[7];
	(digest -> sha512_64_t)[1] = (ctx -> hash.sha512_64_t)[6];
	(digest -> sha512_64_t)[2] = (ctx -> hash.sha512_64_t)[5];
	(digest -> sha512_64_t)[3] = (ctx -> hash.sha512_64_t)[4];
	(digest -> sha512_64_t)[4] = (ctx -> hash.sha512_64_t)[3];
	(digest -> sha512_64_t)[5] = (ctx -> hash.sha512_64_t)[2];
	(digest -> sha512_64_t)[6] = (ctx -> hash.sha512_64_t)[1];
	(digest -> sha512_64_t)[7] = (ctx -> hash.sha512_64_t)[0];
	
	if (!use_le) KOCKET_BE_CONVERT(digest -> sha512_t, SHA512_DIGEST_SIZE);
	
	ctx -> is_finished = TRUE;

	return KOCKET_NO_ERROR;
}

int sha512_final_le(sha_t* digest, sha_ctx* ctx) {
   	return __sha512_final(digest, ctx, TRUE);
}

int sha512_final(sha_t* digest, sha_ctx* ctx) {
	return __sha512_final(digest, ctx, FALSE);
}

static void __sha512(const u8* data, const u64 len, sha_t* digest, const bool use_le) {
	sha_ctx ctx = {0};
	sha512_init(&ctx);
	sha512_update(&ctx, data, len);
	__sha512_final(digest, &ctx, use_le);
	return;
}

void sha512_le(const u8* data, const u64 len, sha_t* digest) {
	__sha512(data, len, digest, TRUE);
	return;
}

void sha512(const u8* data, const u64 len, sha_t* digest) {
	__sha512(data, len, digest, FALSE);
	return;
}

// -----------------------
//  Test SHA-512
// -----------------------

static const u8 test_data[768] = {
	0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0xF8,
	0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1, 0xF0,
	0xEF, 0xEE, 0xED, 0xEC, 0xEB, 0xEA, 0xE9, 0xE8,
	0xE7, 0xE6, 0xE5, 0xE4, 0xE3, 0xE2, 0xE1, 0xE0,
	0xDF, 0xDE, 0xDD, 0xDC, 0xDB, 0xDA, 0xD9, 0xD8,
	0xD7, 0xD6, 0xD5, 0xD4, 0xD3, 0xD2, 0xD1, 0xD0,
	0xCF, 0xCE, 0xCD, 0xCC, 0xCB, 0xCA, 0xC9, 0xC8,
	0xC7, 0xC6, 0xC5, 0xC4, 0xC3, 0xC2, 0xC1, 0xC0,
	0xBF, 0xBE, 0xBD, 0xBC, 0xBB, 0xBA, 0xB9, 0xB8,
	0xB7, 0xB6, 0xB5, 0xB4, 0xB3, 0xB2, 0xB1, 0xB0,
	0xAF, 0xAE, 0xAD, 0xAC, 0xAB, 0xAA, 0xA9, 0xA8,
	0xA7, 0xA6, 0xA5, 0xA4, 0xA3, 0xA2, 0xA1, 0xA0,
	0x9F, 0x9E, 0x9D, 0x9C, 0x9B, 0x9A, 0x99, 0x98,
	0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90,
	0x8F, 0x8E, 0x8D, 0x8C, 0x8B, 0x8A, 0x89, 0x88,
	0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80,
	0x7F, 0x7E, 0x7D, 0x7C, 0x7B, 0x7A, 0x79, 0x78,
	0x77, 0x76, 0x75, 0x74, 0x73, 0x72, 0x71, 0x70,
	0x6F, 0x6E, 0x6D, 0x6C, 0x6B, 0x6A, 0x69, 0x68,
	0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x60,
	0x5F, 0x5E, 0x5D, 0x5C, 0x5B, 0x5A, 0x59, 0x58,
	0x57, 0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50,
	0x4F, 0x4E, 0x4D, 0x4C, 0x4B, 0x4A, 0x49, 0x48,
	0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x40,
	0x3F, 0x3E, 0x3D, 0x3C, 0x3B, 0x3A, 0x39, 0x38,
	0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30,
	0x2F, 0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29, 0x28,
	0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x20,
	0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18,
	0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10,
	0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08,
	0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
	0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0xF8,
	0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1, 0xF0,
	0xEF, 0xEE, 0xED, 0xEC, 0xEB, 0xEA, 0xE9, 0xE8,
	0xE7, 0xE6, 0xE5, 0xE4, 0xE3, 0xE2, 0xE1, 0xE0,
	0xDF, 0xDE, 0xDD, 0xDC, 0xDB, 0xDA, 0xD9, 0xD8,
	0xD7, 0xD6, 0xD5, 0xD4, 0xD3, 0xD2, 0xD1, 0xD0,
	0xCF, 0xCE, 0xCD, 0xCC, 0xCB, 0xCA, 0xC9, 0xC8,
	0xC7, 0xC6, 0xC5, 0xC4, 0xC3, 0xC2, 0xC1, 0xC0,
	0xBF, 0xBE, 0xBD, 0xBC, 0xBB, 0xBA, 0xB9, 0xB8,
	0xB7, 0xB6, 0xB5, 0xB4, 0xB3, 0xB2, 0xB1, 0xB0,
	0xAF, 0xAE, 0xAD, 0xAC, 0xAB, 0xAA, 0xA9, 0xA8,
	0xA7, 0xA6, 0xA5, 0xA4, 0xA3, 0xA2, 0xA1, 0xA0,
	0x9F, 0x9E, 0x9D, 0x9C, 0x9B, 0x9A, 0x99, 0x98,
	0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90,
	0x8F, 0x8E, 0x8D, 0x8C, 0x8B, 0x8A, 0x89, 0x88,
	0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80,
	0x7F, 0x7E, 0x7D, 0x7C, 0x7B, 0x7A, 0x79, 0x78,
	0x77, 0x76, 0x75, 0x74, 0x73, 0x72, 0x71, 0x70,
	0x6F, 0x6E, 0x6D, 0x6C, 0x6B, 0x6A, 0x69, 0x68,
	0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x60,
	0x5F, 0x5E, 0x5D, 0x5C, 0x5B, 0x5A, 0x59, 0x58,
	0x57, 0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50,
	0x4F, 0x4E, 0x4D, 0x4C, 0x4B, 0x4A, 0x49, 0x48,
	0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x40,
	0x3F, 0x3E, 0x3D, 0x3C, 0x3B, 0x3A, 0x39, 0x38,
	0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30,
	0x2F, 0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29, 0x28,
	0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x20,
	0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18,
	0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10,
	0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08,
	0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
	0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0xF8,
	0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1, 0xF0,
	0xEF, 0xEE, 0xED, 0xEC, 0xEB, 0xEA, 0xE9, 0xE8,
	0xE7, 0xE6, 0xE5, 0xE4, 0xE3, 0xE2, 0xE1, 0xE0,
	0xDF, 0xDE, 0xDD, 0xDC, 0xDB, 0xDA, 0xD9, 0xD8,
	0xD7, 0xD6, 0xD5, 0xD4, 0xD3, 0xD2, 0xD1, 0xD0,
	0xCF, 0xCE, 0xCD, 0xCC, 0xCB, 0xCA, 0xC9, 0xC8,
	0xC7, 0xC6, 0xC5, 0xC4, 0xC3, 0xC2, 0xC1, 0xC0,
	0xBF, 0xBE, 0xBD, 0xBC, 0xBB, 0xBA, 0xB9, 0xB8,
	0xB7, 0xB6, 0xB5, 0xB4, 0xB3, 0xB2, 0xB1, 0xB0,
	0xAF, 0xAE, 0xAD, 0xAC, 0xAB, 0xAA, 0xA9, 0xA8,
	0xA7, 0xA6, 0xA5, 0xA4, 0xA3, 0xA2, 0xA1, 0xA0,
	0x9F, 0x9E, 0x9D, 0x9C, 0x9B, 0x9A, 0x99, 0x98,
	0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90,
	0x8F, 0x8E, 0x8D, 0x8C, 0x8B, 0x8A, 0x89, 0x88,
	0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80,
	0x7F, 0x7E, 0x7D, 0x7C, 0x7B, 0x7A, 0x79, 0x78,
	0x77, 0x76, 0x75, 0x74, 0x73, 0x72, 0x71, 0x70,
	0x6F, 0x6E, 0x6D, 0x6C, 0x6B, 0x6A, 0x69, 0x68,
	0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x60,
	0x5F, 0x5E, 0x5D, 0x5C, 0x5B, 0x5A, 0x59, 0x58,
	0x57, 0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50,
	0x4F, 0x4E, 0x4D, 0x4C, 0x4B, 0x4A, 0x49, 0x48,
	0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x40,
	0x3F, 0x3E, 0x3D, 0x3C, 0x3B, 0x3A, 0x39, 0x38,
	0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30,
	0x2F, 0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29, 0x28,
	0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x20,
	0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18,
	0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10,
	0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08,
	0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00
};

int test_sha512(void) {
	sha_t hash = {0};
	sha_t hash_le = {0};
	
	const u8 data[] = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu";
	printf("Testing SHA-512:\n");
	sha512(data, KOCKET_ARR_SIZE(data) - 1, &hash);
	sha512_le(data, KOCKET_ARR_SIZE(data) - 1, &hash_le);

	static const sha_t test_sha_le = {
		.sha512_t = {
			0x09, 0xE9, 0x4B, 0x87, 0x5B, 0xE5, 0x96, 0x5E,
			0x54, 0x26, 0xDD, 0xB6, 0xEE, 0x29, 0xD3, 0xC7,
			0x3A, 0x43, 0xB5, 0xC4, 0xDE, 0x99, 0x1B, 0x33,
			0xE4, 0xF7, 0x00, 0x49, 0x9E, 0x28, 0x1D, 0x50,
			0x18, 0x90, 0x88, 0xB6, 0xAD, 0xAE, 0x99, 0x72,
			0xA1, 0x7F, 0x9F, 0xEB, 0xC6, 0x79, 0x77, 0x8F,
			0x3F, 0x14, 0xFC, 0x14, 0x28, 0xF7, 0xF4, 0x8C,
			0xDA, 0x13, 0xE3, 0xDA, 0x75, 0x9B, 0x95, 0x8E
		}
	};
	
	sha_t test_sha = {0};
	mem_cpy(test_sha.sha512_t, test_sha_le.sha512_t, sizeof(test_sha.sha512_t));
	KOCKET_BE_CONVERT(test_sha.sha512_t, sizeof(test_sha.sha512_t));

	if (mem_cmp(hash.sha512_t, test_sha.sha512_t, sizeof(test_sha.sha512_t))) {
		printf("Failed test sha512.\n");
		printf("HASHED: \n");
		PRINT_HASH(hash);
		printf("Expected: \n");
		PRINT_HASH(test_sha);
		return 1;
	}

	PRINT_HASH(hash);
	PRINT_HASH(test_sha);
	
	if (mem_cmp(hash_le.sha512_t, test_sha_le.sha512_t, sizeof(test_sha_le.sha512_t))) {
		printf("Failed test sha512.\n");
		printf("HASHED: \n");
		PRINT_HASH(hash_le);
		printf("Expected: \n");
		PRINT_HASH(test_sha_le);
		return 1;
	}

	PRINT_HASH(hash_le);
	PRINT_HASH(test_sha_le);
	
	printf("\n -------- Test sha512 multi update  ----------\n\n");
	
	sha_ctx ctx = {0};
	sha512_init(&ctx);

	const unsigned int splits[] = { 127, 2, 1, 128, 17, 300, 193 };
	unsigned char test_data_be[768] = {0};
	mem_cpy(test_data_be, test_data, 768);
	KOCKET_BE_CONVERT(test_data_be, 768);

	sha_t digest = {0};
	unsigned int offset = 0;
	for (unsigned int i = 0; i < KOCKET_ARR_SIZE(splits); ++i) {
		sha512_update(&ctx, test_data_be + offset, splits[i]);
		PRINT_HASH(ctx.hash);
		offset += splits[i];
	}

	sha512_final(&digest, &ctx);
	PRINT_HASH(digest);

	sha_t digest_two = {0};
	sha512(test_data_be, KOCKET_ARR_SIZE(test_data_be), &digest_two);
	PRINT_HASH(digest_two);

	if (mem_cmp(digest.sha512_t, digest_two.sha512_t, sizeof(digest.sha512_t))) {
		WARNING_LOG("digest mismatch");
		return -1;
	}
	
	return KOCKET_NO_ERROR;
}

#endif //_SHA512_H_

